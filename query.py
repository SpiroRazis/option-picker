from query_components import OptionList, OptionData, OptionKey, OptionValue, PromptStatement
import itertools as iter

class Query:

    _HAS_CUSTOM_KEYS = 1
    _HAS_AUTO_KEYS = 2

    def __init__(self):
        self._input_symbol = "-->"
        self._prompt = None
        self._option_list = OptionList()
        self._key_type = None
        self._key_generator = iter.count(1, 1)
        self._is_built = False
        self._input_string = ""
        self._input_list = []
        self._validated_keys = []
        self._key_value_pairs = []
        self._query_return = []

    # QUERY ####################################################
    def query(self):
        if self._is_built:
            try:
                self._executeQuery()
                return self._query_return
            except ValueError as e:
                print(e)
                raise ValueError("Unable to Query")
        else:
            raise ValueError("Not Built")

    # SET ####################################################
    def setPrompt(self, prompt):
        if self._is_built:
            raise ValueError("Already Built")
        try:
            if isinstance(prompt, str):
                self._prompt = PromptStatement(prompt)
            elif isinstance(prompt, PromptStatement):
                self._prompt = prompt
            else:
                raise TypeError("Invalid prompt type!")
            return self
        except (ValueError, TypeError) as e:
            print(e)
            raise ValueError("Unable to set prompt!")

    # ADD ####################################################
    """
    IF *ARGS LENGTH IS 1, THEN PARAMETER IS VALUE AND THE KEY IS AUTOGENERATED
    ELSE IF *ARGS LENGTH IS 2, THEN USES (KEY, VALUE) APPROACH
    ELSE, AN ERROR IS THROWN
    CANT MIX THE TWO TYPES IN A SINGLE QUERY
    EITHER FULLY CUSTOMIZED OR FULLY AUTOMATIC
    """
    def addOption(self, *args):
        if self._is_built:
            raise ValueError("Already Built")
        else:
            try:
                key_string, value_string = self._parseOptionArgs(args)
                if key_string:
                    self._validateKeyUsage(self._HAS_CUSTOM_KEYS)
                else:
                    self._validateKeyUsage(self._HAS_AUTO_KEYS)
                    key_string = str(next(self._key_generator))
                    print(key_string)
                self._option_list.addOption(OptionData(key_string, value_string))
                return self
            except (ValueError, TypeError) as e:
                print(e)
                raise ValueError("Unable to add the option!")

    ##########################
    def _validateKeyUsage(self, key_type):
        if not self._key_type:
            self._key_type = key_type
        elif self._key_type != key_type:
            raise TypeError("Can't mix custom and auto-generated keys!")
        return

    ##########################
    def _parseOptionArgs(self, arg_list):
        key_string = ""
        value_string = ""
        print(arg_list)
        if len(arg_list) == 1:
            if isinstance(arg_list[0], str):
                value_string = arg_list[0]
            else:
                raise TypeError("Expected a string!")
        elif len(arg_list) == 2:
            if isinstance(arg_list[0], str) and isinstance(arg_list[1], str):
                key_string = arg_list[0]
                value_string = arg_list[1]
            elif not (isinstance(arg_list[0], str) or isinstance(arg_list[1], str)):
                raise TypeError("Neither key nor value are strings!")
            elif isinstance(arg_list[0], str):
                raise TypeError("Expected a string in the value field!")
            else:
                raise TypeError("Expected a string in the key field!")
        else:
            raise ValueError("Invalid number of arguments!")
        return key_string, value_string

    # FINALIZE ####################################################
    def build(self):
        if self._is_built:
            raise ValueError("Already Built")
        else:
            if self._prompt and (len(self._option_list) > 0):
                self._is_built = True
                return self
            else:
                raise ValueError("Incomplete Query Build")

    # QUERY ####################################################
    def _executeQuery(self):
        self._clearPlaceholderFields()
        self._clearQueryReturn()
        self._printPrompt()
        self._printOptions()
        try:
            self._requestInput()
            self._parseInput()
            self._validateInput()
            self._collapseRepeatKeys()
            self._getKeyValuePairs()
            self._updateQueryReturn()
            self._clearPlaceholderFields()
        except ValueError as e:
            print(e)
            self._clearPlaceholderFields()
            raise ValueError("Invalid Query")

    ##########################
    def _clearPlaceholderFields(self):
        self._clearInputString()
        self._clearInputList()
        self._clearValidatedKeys()
        self._clearKeyValuePairs()

    def _clearInputString(self):
        self._input_string = ""

    def _clearInputList(self):
        self._input_list = []

    def _clearValidatedKeys(self):
        self._validated_keys = []

    def _clearKeyValuePairs(self):
        self._key_value_pairs = []

    def _clearQueryReturn(self):
        self._query_return = []

    #####################################
    def _printPrompt(self):
        print(str(self._prompt))

    def _printOptions(self):
        self._option_list._printOptions()

    def _requestInput(self):
        self._input_string = input(self._input_symbol).strip()

    def _parseInput(self):
        if self._input_string:
            self._input_list = self._input_string.split()
        else:
            raise ValueError("Empty String")

    def _validateInput(self):
        if self._input_list:
            try:
                for string in self._input_list:
                    if OptionKey(string) in self._option_list:
                        self._validated_keys.append(string)
                    else:
                        raise ValueError("Provided input not amongst options")
            except ValueError as e:
                print(e)
                raise ValueError("Invalid Input: %s" % string)
        else:
            raise ValueError("Empty List")

    def _collapseRepeatKeys(self):
        self._validated_keys.sort()
        collapsed_keys = []
        for valid_key_string in self._validated_keys:
            if collapsed_keys:
                if valid_key_string != collapsed_keys[-1]:
                    collapsed_keys.append(valid_key_string)
            else:
                collapsed_keys.append(valid_key_string)
        self._validated_keys = collapsed_keys

    def _getKeyValuePairs(self):
        try:
            # print(self._validated_keys)
            for key in self._validated_keys:
                # print(key)
                # print(type(key))
                option_key, option_value = self._option_list.getOptionByKey(key)\
                                            .getData()
                self._key_value_pairs.append((option_key.getData(), \
                                                option_value.getData()))
        except KeyError as e:
            print(e)
            raise KeyError("Could not find a validated key?")

    def _updateQueryReturn(self):
        self._query_return = self._key_value_pairs
