from query_components import OptionList, OptionData, SelectorData, TextData
import itertools as iter

class Query:

    _HAS_CUSTOM_SELECTORS = 1
    _HAS_AUTO_SELECTORS = 2

    def __init__(self):
        self._input_symbol = "-->"
        self._prompt = None
        self._option_list = OptionList()
        self._selector_type = None
        self._selector_generator = iter.count(1, 1)
        self._is_built = False
        self._input_string = ""
        self._input_list = []
        self._validated_input_list = []
        self._query_return = []

    # PUBLIC ##########################
    def query(self):
        if self._is_built:
            try:
                self._executeQuery()
                return self._query_return
            except ValueError as e:
                print(e)
                raise ValueError("Unable to Query")
        else:
            raise ValueError("Not Built")

    # SET ##########################
    def setPrompt(self, text):
        if self._is_built:
            raise ValueError("Already Built")
        else:
            self._prompt = TextData(text)
            return self

    # ADD ##########################
    """
    IF *ARGS LENGTH IS 1, THEN PARAMETER IS TEXT, AND SELECTOR IS AUTOGENERATED
    ELSE IF *ARGS LENGTH IS 2, THEN USES (SELECTOR, TEXT) APPROACH
    ELSE, AN ERROR IS THROWN
    CANT MIX THE TWO TYPES IN A SINGLE QUERY
    EITHER FULLY CUSTOMIZED OR FULLY AUTOMATIC
    """
    def addOption(self, *args):
        if self._is_built:
            raise ValueError("Already Built")
        else:
            try:
                selector_string, text_string = self._parseOptionArgs(args)
                if selector_string:
                    self._validateSelectorUsage(self._HAS_CUSTOM_SELECTORS)
                else:
                    self._validateSelectorUsage(self._HAS_AUTO_SELECTORS)
                    selector_string = str(next(self._selector_generator))
                    print(selector_string)
                self._option_list.addOption(OptionData(selector_string, text_string))
                return self
            except (ValueError, TypeError) as e:
                print(e)
                raise ValueError("Unable to add the option!")

    #############
    def _validateSelectorUsage(self, selector_type):
        if not self._selector_type:
            self._selector_type = selector_type
        elif self._selector_type != selector_type:
            raise TypeError("Can't mix custom and auto-generated selectors!")
        return

    #############
    def _parseOptionArgs(self, arg_list):
        selector_string = ""
        text_string = ""
        print(arg_list)
        if len(arg_list) == 1:
            if isinstance(arg_list[0], str):
                text_string = arg_list[0]
            else:
                raise TypeError("Expected a string in the text field!")
        elif len(arg_list) == 2:
            if isinstance(arg_list[0], str) and isinstance(arg_list[1], str):
                selector_string = arg_list[0]
                text_string = arg_list[1]
            elif not (isinstance(arg_list[0], str) or isinstance(arg_list[1], str)):
                raise TypeError("Neither selector nor text are strings!")
            elif isinstance(arg_list[0], str):
                raise TypeError("Expected a string in the text field!")
            else:
                raise TypeError("Expected a string in the selector field!")
        else:
            raise ValueError("Invalid number of arguments!")
        return selector_string, text_string

    # FINALIZE ##########################
    def build(self):
        if self._is_built:
            raise ValueError("Already Built")
        else:
            if self._prompt and (len(self._option_list) > 0):
                self._is_built = True
                return self
            else:
                raise ValueError("Incomplete Query Build")

    # QUERY ##########################
    def _executeQuery(self):
        self._clearInputFields()
        self._clearQueryReturn()
        self._printPrompt()
        self._printOptions()
        try:
            self._requestInput()
            self._parseInput()
            self._validateInput()
            self._collapseInputRepeats()
            self._updateQueryReturn()
            self._clearInputFields()
        except ValueError as e:
            print(e)
            self._clearInputFields()
            raise ValueError("Invalid Query")

    #####################################
    def _clearInputFields(self):
        self._clearInputString()
        self._clearInputList()
        self._clearValidatedInputList()

    def _clearInputString(self):
        self._input_string = ""

    def _clearInputList(self):
        self._input_list = []

    def _clearValidatedInputList(self):
        self._validated_input_list = []

    def _clearQueryReturn(self):
        self._query_return = []

    #####################################
    def _printPrompt(self):
        print(str(self._prompt))

    def _printOptions(self):
        self._option_list._printOptions()

    def _requestInput(self):
        self._input_string = input(self._input_symbol).strip()

    def _parseInput(self):
        if self._input_string:
            self._input_list = self._input_string.split()
        else:
            raise ValueError("Empty String")

    def _validateInput(self):
        if self._input_list:
            try:
                for string in self._input_list:
                    if SelectorData(string) in self._option_list:
                        self._validated_input_list.append(string)
                    else:
                        raise ValueError("Provided input not amongst options")
            except ValueError as e:
                print(e)
                raise ValueError("Invalid Input: %s" % string)
        else:
            raise ValueError("Empty List")

    def _collapseInputRepeats(self):
        self._validated_input_list.sort()
        collapsed_input = []
        for valid_input_string in self._validated_input_list:
            if collapsed_input:
                if valid_input_string != collapsed_input[-1]:
                    collapsed_input.append(valid_input_string)
            else:
                collapsed_input.append(valid_input_string)
        self._validated_input_list = collapsed_input

    def _updateQueryReturn(self):
        self._query_return = self._validated_input_list
